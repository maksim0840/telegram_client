# [Telegram Desktop][telegram_desktop] – Official Messenger

# Пользователский клиент
-является дополнением к основнуму клиенту talegram версии 5.9.0 Клиент создан для безопасной работы, отпраки и полчучения сообщений.

# Изменяемый код
Чтобы быть точно уверенным, что отправляемые сообщения шифруются и телеграм не имеет к ним доступ, требуется перехватывать сообщение на более ранних стадиях его формирования. Сообщения будут шифроваться на этапе захвата графическим интерфейсом строки из input_field.

# Сборка оиргинального клиента
Оригинальный клиент и инструкция по билду находится в ветке telegram-5.9.0 После сборки готовый клиент будет находится в папке tdesktop/out/Release

# Сборка пользовательского клиента

Расширенный клиент телеграмма находится в main ветке. Сборка происходит также, как и в оригинальном клиенте. Сбилдить проект можно также при помощи build.sh скрипта, находящегося в папке проекта tdesktop. Для наиболее эфективной сборки выставите подходящее количество cpu, ram и gpu (для подключения gpu следует дополнительно ознакомиться с документацией запуска docker файла через gpu и настроить своё окружение)

Запустить проект можно при помощи скрипта run.sh или напрямую через файл Telegram, находящийся в дирректории tdesktop/out/Release.

Параметры, использующиеся для сборки:

- api_id: 23244845

- api_hash: 47b3b70ac69586b8fd2b55ec2e751aa4

# Ход работы:

1) При нажатии на кнопку "отправить", вызывается функция getTextWithAppliedMarkdown (находится в Telegram/lib_ui/ui/widgets/fields/input_field.cpp). Она возрващает объект input-поля, содержащий отправляемое сообщение.

2) Для реализации шифровки сообщений, которые отправляются через набор текста в input-поле требуется знание id пользователя (группы), которому было отправлено это сообщение. Эта информация содержится в методе send (находится в Telegram/SourceFiles/history/history_widget.cpp). Эта функиця вызывает getTextWithAppliedMarkdown из первого пункта, но так же ещё позволяет получить id пользователя/группы к которому отправляется сообщение) - с помощью этой функции реализована шифровка сообщений, которые отправляются в большой групповой, парный и saved masseges чаты. Поддерживается отправка сообщений следующих видов написания: обычная отправка, ответ, редактирование (за редактирование отвечает другая функция этого же файла - prepareTextForEditMsg).

3) Не все типы отправляемых сообщений поддерживаются функцией getTextWithAppliedMarkdown: Шифровка пересылаемых сообщений (forwared messages) не связана с функцией getTextWithAppliedMarkdown, надо находить другую функцию или смириться с тем фактом, что пересылать сообщенния из зашифрованных чатов является не лучшей идеей.

4) Была создана папка (Telegram/lib_extension) для основного кода расширения. CMakeLists расширения был создан на основе CMakeLists из папки Telegram/codegen/codegen/common. На данный момент папка проекта использует только базовые библиотеки c++ и библиотеку qt, когторая подключается благодаря связывания папки со всей структурой проекта (данная папка была добавлена в главный cmakelists файл проекта telegram).

5) В качестве функции, которая шифрует сообщение в файл с расширением к основному клиенту была добавлена функция encrypt_the_message (папки Telegram/lib_extension/extension/encryption). На вход она принимает ссылку на текст сообщения и константый id пользователя, по которому определяется способ шифровки и изменяется сообщение)

6) За сообщение связанное с прикреплёнными файлами в диалоге отвечает другой метод другого файла проекта: send_files_box.cpp из папки Telegram/SourceFiles/boxes/send_files_box.cpp

7) В папку с расширением был добавлен код для реализации шифрования и генерации ключей при помощи библиотеки openssl, которая теперь также подключается к файлам расширения. (файлы: Telegram/lib_extension/extension/encryption/keys_creator)

8) В папку с расширением был добавлен код для реализации базы данных sqllite, хранящей информацию о ключах. Сама база временно хранится в папке с расширением по пути Telegram/lib_extension/db/keys.db, а сам код Telegram/lib_extension/extension/local_storage/local_storage





*9) Telegram/lib_ui/ui/text/text_renderer.cpp - метод draw в файле Telegram/lib_ui/ui/text/text_renderer.cpp отвечает за отрисовку сообщений в графическом интрфейсе и постоянно вызывается, что означает она не подходит для эффективного декодирования

10) решил снова проверить файл history_widget и нашёл несколько функций отвечающие за загрузку сообщений в кэш отвечает функция preloadHistoryByScroll. Данная функция вызывает loadMessages если в кэше нет сообщений требуемого чата или функцию loadMessagesDown которая вызвается каждый раз при появлении нового сообщения или при скролле страницы.

Функция loadMessages вызывает messagesReceived которая подгружает предыдущие сообщения пачкой по несколько штук (вывод сообщений в программе крашится если в чате есть звонки).
Функция loadMessagesDown запрашивает данные о сообщениях через session().sponsoredMessages().request(_history, nullptr). request вызывает функцию parse где обрабатываются сообщения чата.

почему то не работает поэтому я пробую через метод history.cpp createItem.
В функции parse файла Telegram/SourceFiles/data/components/sponsored_messages.cpp Я сделал чтение сообщений


/SourceFiles/history/view/history_view_message.cpp
Telegram/SourceFiles/history/history_widget.cpp

11) Было принято решение дополнительно все ключи шифровать в строковом формате Base64. Т.к. данный тип исключает специальные символы и легко пердаются через сообщения в телеграм.

-----------
Пункты 1-6 предполагают добавление новой папки lib_extension в проект telegram и добавление 3-ёх строчек в файл history_widget.cpp (первая строчка - включение дополнения через include, вторая строчка - функция шифровки сообщения для отправки простого сообщения и для его ответа в методе send, третья строчка - функция шифровки сообщения для редактирования сообщения в методе prepareTextForEditMsg) и ещё 2-ух строек в файл send_files_box.cpp (первая строчка - включение дополнения через include, вторая строчка - функция шифровки сообщения для отправки простого сообщения send)
-----------



Стоит изучить:

*data_shortcut_messages - возможная быстрая панель сообщений


Поелзные команды, но не используются:

peer()->asChat()->participants - id участников чата
